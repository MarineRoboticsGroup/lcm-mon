#!/usr/bin/python3
import lcm
import urwid
import threading
import matplotlib.pyplot as plt
import numpy as np
import optparse
import time
import tempfile
import itertools
import os
import glob
import shutil
import subprocess
import importlib.util
import sys

command = ""

class Spinner:
    def __init__(self):
        self._spinner = itertools.cycle(['|', '/', '-', '\\'])

    def spin(self):
        return next(self._spinner)

class Row(urwid.Columns):
    def __init__(self, layout, labels, selectable):
        self._widgets = [urwid.Text(label) for label in labels]
        config = [(*s, w) for s, w in zip(layout, self._widgets)]
        urwid.Columns.__init__(self, config)
        self._selectable = selectable

    def keypress(self, size, key):
        return key

    def selectable(self):
        return self._selectable

    def set_labels(self, labels):
        for widget, label in zip(self._widgets, labels):
            if label is not None:
                widget.set_text(label)

class ReadLog(lcm.EventLog):
    def __init__(self, path, playback_speed=1.0):
        lcm.EventLog.__init__(self, path, mode="r")
        self._path = path
        self._playback_speed = playback_speed
        self._playing = threading.Event()
        self._playing.set()
        self._first_time = None
        self._time = 0.0
        self._lock = threading.Lock()
        offset = 0
        while True:
            self.seek(self.size() - offset)
            try:
                last_timestamp = lcm.EventLog.next(self).timestamp
                break
            except StopIteration:
                pass
            offset += 1
        self.seek(0)
        first_timestamp = lcm.EventLog.next(self).timestamp
        self.seek(0)
        self._last_time = (last_timestamp - first_timestamp) / 1e6

    def path(self):
        return self._path

    def get_playback_speed(self):
        return self._playback_speed

    def set_playback_speed(self, speed):
        self._playback_speed = speed

    def pause(self):
        self._playing.clear()

    def resume(self):
        self._playing.set()

    def is_playing(self):
        return self._playing.is_set()

    def position(self):
        return self._time

    def length(self):
        return self._last_time

    def seek_to_time(self, t):
        timestamp = int(1e6 * (t + self._first_time))
        self._lock.acquire()
        self.seek_to_timestamp(timestamp)
        self._time = t
        self._delay = None
        self._lock.release()

    def play_next(self):
        self._playing.wait()
        if self.next() is not None:
            time.sleep(self._delay / self._playback_speed)
        return self._event

    def next(self):
        self._lock.acquire()
        try:
            self._event = lcm.EventLog.next(self)
        except StopIteration:
            self._event = None
        if self._event is not None:
            if self._first_time is None:
                self._first_time = self._event.timestamp / 1e6
                self._time = 0.0
                self._delay = 0.0
            else:
                event_time = self._event.timestamp / 1e6 - self._first_time
                self._delay = max(event_time - self._time, 0.0)
                self._time = event_time
        self._lock.release()
        return self._event

class WriteLog(lcm.EventLog):
    def __init__(self, path):
        lcm.EventLog.__init__(self, path, mode="w", overwrite=True)
        self._path = path

    def path(self):
        return self._path

class StatusBar(Row):
    def __init__(self):
        self._state = self.default()
        Row.__init__(self, self.layout(), self._get_label(self._state), False)

    def fields(self):
        raise NotImplementedError

    def layout(self):
        raise NotImplementedError

    def default(self):
        raise NotImplementedError

    def state(self):
        return self._state

    def update(self):
        self.set_labels(self._get_label(self._state))

    def set(self, **mapping):
        self._state = mapping
        self.update()

    def reset(self):
        self._state = self.default()
        self.update()

    def _get_label(self, mapping):
        labels = []
        for field in self.fields():
            if field in mapping:
                pretty_print = getattr(self, "print_" + field)
                value = mapping[field]
                labels.append(pretty_print(value))
            else:
                labels.append(None)
        return labels

class LCMStatusBar(StatusBar):
    def __init__(self):
        self._path = ""
        StatusBar.__init__(self)
        self._spinner = Spinner()
        self._read_format = u"\u25b2 {} {:.3f}s / {:.3f}s @ {}x"
        self._write_format = u"   \u25bc {} {:.3f} kB"
        self._dumped_format = u"   \u25bc Wrote {}"
        self.spin()

    def spin(self):
        self._spin = self._spinner.spin()

    def layout(self):
        return [("weight", 1), ("pack",), ("pack",)]

    def fields(self):
        return ["command", "read", "write"]

    def default(self):
        return { "command" : "", "read" : None, "write" : None }

    def reset(self):
        StatusBar.reset(self)
        self._path = ""

    def print_command(self, command):
        if command is None:
            return ""
        else:
            return command

    def print_read(self, log):
        if log is None:
            return ""
        else:
            if log.is_playing():
                spin = self._spin
            else:
                spin = u"\u00b7"
            position = log.position()
            total = log.length()
            speed = log.get_playback_speed()
            return self._read_format.format(spin, position, total, speed)

    def print_write(self, log):
        if log is None:
            if self._path is "":
                return ""
            else:
                return self._dumped_format.format(self._path)
        elif type(log) == type(""):
            self._path = log
            if self._path is "":
                return ""
            else:
                return self._dumped_format.format(self._path)
        else:
            spin = self._spin
            written = log.tell() / 1e3
            return self._write_format.format(spin, written)

class Database:
    def __init__(self, header, body=[]):
        self._entries = []
        self._body = body
        self._body.append(self.format_header(header))
        self._begin = len(self._body)

    def append(self, entry):
        self._entries.append(entry)
        self._body.append(self.format_entry(entry))

    def extend(self, entries):
        self._entries.extend(entries)
        for entry in entries:
            self._body.append(self.format_entry(entry))

    def clear(self):
        self._entries.clear()
        del self._body[self._begin:]

    def __getitem__(self, index):
        return self._entries[index]

    def __setitem__(self, index, entry):
        self._entries[index] = entry
        self._body[self._begin+index] = self.format_entry(entry)

    def __delitem__(self, index):
        del self._entries[index]
        del self._body[self._begin+index]

    def search(self, matches):
        try:
            return next(i for i, entry in enumerate(self._entries) if matches(entry))
        except StopIteration:
            return None

    def entries(self):
        return self._entries

    def body(self):
        return self._body

    def format_header(self, header):
        raise NotImplementedError

    def format_entry(self, entry):
        raise NotImplementedError

class CustomListBox(urwid.ListBox):
    def __init__(self, body, callback=id):
        urwid.ListBox.__init__(self, body)
        self._callback = callback
        self._previous_focus = None

    def on_focus_change(self):
        try:
            focus = self.focus_position - 1
        except IndexError:
            return None
        if focus > 0 and not focus == self._previous_focus:
            self._previous_focus = focus
            self._callback(focus)

    def keypress(self, size, key):
        result = urwid.ListBox.keypress(self, size, key)
        self.on_focus_change()
        return result

    def mouse_event(self, size, event, button, col, row, focus):
        result = urwid.ListBox.mouse_event(self, size, event, button, col, row, focus)
        self.on_focus_change()
        return result

class Table(Database):
    def __init__(self, header, layout, callback=id, divided=False):
        self._n = len(header)
        self._layout = layout
        self._walker = urwid.SimpleFocusListWalker([])
        self._table = CustomListBox(self._walker, callback=self._focus_callback)
        Database.__init__(self, header, body=self._walker)
        self._callback = callback
        self._divided = divided

    def widget(self):
        return self._table

    def _focus_callback(self, focus):
        self._callback(self[focus])

    def format_header(self, header):
        widget = Row(self._layout, header, False)
        return urwid.Pile([urwid.AttrMap(widget, "item.header")])

    def format_entry(self, entry):
        widget = Row(self._layout, entry[:self._n], True)
        if self._divided:
            widget = urwid.LineBox(widget)
        return urwid.AttrMap(widget, "item.normal", "item.focus")

class LCMState:
    def __init__(self):
        self.reset()

    def reset(self):
        self._write_log = None
        self._read_log = None
        self._refresh_rate = 1.5
        self._channel = None
        self._class = None
        self._lock = threading.Lock()
        self._current_channel = None
        self._current_class = None

    def lock(self):
        self._lock.acquire()

    def unlock(self):
        self._lock.release()

def load_lcm_modules(folders):
    lcm_files = []
    for folder in folders:
        lcm_pattern = os.path.join(folder, "**/*.lcm")
        lcm_files.extend(glob.glob(lcm_pattern, recursive=True))
    lcm_dir = tempfile.mkdtemp()
    for lcm_file in lcm_files:
        filename = os.path.basename(lcm_file)
        dest_file = os.path.join(lcm_dir, filename)
        new_lcm_file = shutil.copyfile(lcm_file, dest_file)
        subprocess.call(["lcm-gen", "-p", new_lcm_file,
            "--ppath", lcm_dir,
            "--python-no-init"])
    py_pattern = os.path.join(lcm_dir, "**/*.py")
    py_files = glob.glob(py_pattern, recursive=True)
    lcm_classes = []
    for py_file in py_files:
        module_name = os.path.basename(py_file).split(".")[0]
        spec = importlib.util.spec_from_file_location(module_name, py_file)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        lcm_classes.append(getattr(module, module_name))
    return lcm_classes

def is_float(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

def parse_command(command_string, current_state):
    args = command_string.split()
    if args[0] == ":q" or args[0] == ":quit":
        return "quit", []
    elif args[0] == ":l" or args[0] == ":log":
        if current_state._write_log is None:
            if len(args) == 1:
                filename = None
            elif len(args) == 2:
                filename = args[1]
            else:
                return None, []
            return "start_write_log", [filename]
        else:
            return "stop_write_log", []
    elif args[0] == ":play" or args[0] == ":p":
        if current_state._read_log is None:
            if len(args) == 2:
                return "start_read_log", [args[1], None]
            elif len(args) == 3 and is_float(args[2]):
                return "start_read_log", [args[1], float(args[2])]
            else:
                return None, []
        elif len(args) == 2 and is_float(args[1]):
            speed = float(args[1])
            return "set_playback_speed", [speed]
        elif len(args) == 1:
            if current_state._read_log.is_playing():
                return "pause_read_log", []
            else:
                return "resume_read_log", []
        else:
            return None, []
    elif args[0] == ":pause":
        if current_state._read_log is not None:
            if current_state._read_log.is_playing():
                return "pause_read_log", []
            else:
                return None, []
        else:
            return None, []
    elif args[0] == ":s" or args[0] == ":seek":
        if current_state._read_log is not None:
            if len(args) == 2 and is_float(args[1]):
                if args[1][0] == "+" or args[1][0] == "-":
                    seek_time = current_state._read_log.position() + float(args[1])
                else:
                    seek_time = float(args[1])
                return "seek_read_log", [seek_time]
            else:
                return None, []
        else:
            return None, []
    elif args[0] == ":r" or args[0] == ":refresh":
        if len(args) == 1 and is_float(args[1]):
            rate = float(args[1])
            return "set_refresh_rate", [rate]
    elif args[0] == ":c" or args[0] == ":clear":
        return "clear", []
    else:
        return None, []

def run_command(command):
    action, args = parse_command(command, state)
    if action == "quit":
        raise urwid.ExitMainLoop()
        return True
    elif action == "start_write_log":
        if args[0] is None:
            path = tempfile.mkstemp(prefix="lcmlog-", dir=".")
        else:
            path = args[0]
        state.lock()
        state._write_log = WriteLog(path)
        state.unlock()
        status.set(write=state._write_log)
    elif action == "stop_write_log":
        path = state._write_log.path()
        state.lock()
        state._write_log = None
        state.unlock()
        status.set(write=path)
    elif action == "start_read_log":
        if args[1] is None:
            state._read_log = ReadLog(args[0])
        else:
            state._read_log = ReadLog(args[0], playback_speed=args[1])
        status.set(read=state._read_log)
        read_log_thread = threading.Thread(target=play_log, args=(node, state))
        read_log_thread.setDaemon(True)
        read_log_thread.start()
    elif action == "set_playback_speed":
        state._read_log.set_playback_speed(args[0])
    elif action == "pause_read_log":
        state._read_log.pause()
    elif action == "resume_read_log":
        state._read_log.resume()
    elif action == "seek_read_log":
        state._read_log.seek_to_time(args[0])
    elif action == "set_refresh_rate":
        state._refresh_rate = args[1]
    elif action == "clear":
        state.lock()
        state._current_channel = None
        state._current_class = None
        table.clear()
        data_table.clear()
        if state._write_log is None:
            status.set(write="")
        state.unlock()
    else:
        raise ValueError

def handle_input(key):
    global command
    if command == "" or not command[0] == ":":
        command = ""
        if key == ":":
            command += key.lower()
    else:
        if key == "enter":
            try:
                run_command(command)
                command = ""
            except ValueError:
                command = "Unrecognized command or invalid syntax"
            except urwid.ExitMainLoop:
                raise urwid.ExitMainLoop
            except:
                command = "Unhandled exception: {}".format(sys.exc_info()[0])
        elif key == "backspace":
            command = command[:-1]
        elif key == "esc":
            command = ""
        elif len(key) == 1:
            command += key.lower()
    status.set(command=command)

def pretty_hz(hz):
    return "{:5.2f}".format(hz).rjust(7)

def pretty_msg(msg):
    def valid_variable(name):
        specials = ["decode", "encode"]
        return not (name[:1] == "_" or name in specials)
    def value(variable):
        val = getattr(msg, variable)
        if type(val) == type(()) or type(val) == type([]):
            return os.linesep.join(["[%i] %s" % (i, v) for i, v in enumerate(val)])
        else:
            return str(val)
    variables = [variable for variable in dir(msg) if valid_variable(variable)]
    return list(zip(variables, [value(variable) for variable in variables]))

def handle_lcm(node, table):
    def lcm_event(channel, data):
        i = table.search(lambda entry: entry[0] == channel)
        if i is None:
            table.append((channel, "--", time.time(), data))
        else:
            framerate = 1 / (time.time() - table[i][2])
            table[i] = (channel, pretty_hz(framerate), time.time(), data)
        if state._write_log is not None:
            timestamp = int(time.time() * 1e6)
            state._write_log.write_event(timestamp, channel, data)
    subscription = node.subscribe(".*", lcm_event)
    while True:
        node.handle()

def play_log(node, state):
    while True:
        event = state._read_log.play_next()
        if event is None:
            break
        else:
            node.publish(event.channel, event.data)
    state._read_log = None
    status.set(read=None)

def refresh_screen(_loop, _data):
    state.lock()
    status.spin()
    status.set(read=state._read_log, write=state._write_log)
    if state._current_channel is not None:
        i = table.search(lambda entry: entry[0] == state._current_channel)
        data = table[i][3]
        msg = state._current_class.decode(data)
        for i, (variable, value) in enumerate(pretty_msg(msg)):
            data_table[i] = (variable, value)
    state.unlock()
    _loop.draw_screen()
    _loop.set_alarm_in(1 / state._refresh_rate, refresh_screen)

def show_data(entry):
    state.lock()
    data_table.clear()
    data = entry[3]
    for lcm_class in lcm_classes:
        try:
            msg = lcm_class.decode(data)
            break
        except ValueError:
            pass
    else:
        state._current_channel = None
        state._current_class = None
        state.unlock()
        return False
    data_table.extend(pretty_msg(msg))
    state._current_channel = entry[0]
    state._current_class = lcm_class
    state.unlock()
    return True

header = ["== CHANNEL ==", "== HZ =="]
layout = [("weight", 1), (8,)]

data_header = ["== VARIABLE ==", "== VALUE =="]
data_layout = [("weight", 1), ("weight", 1)]

if __name__ == "__main__":
    sys.stdout.write("\x1b]2;lcm-mon\x07")

    parser = optparse.OptionParser()

    # parser.add_option("-u", "--url", dest="url", help="Capture packets from LCM_URL", metavar="LCM_URL", default="udpm://239.255.76.67:7667?ttl=1")
    parser.add_option("-t", "--types", dest="types", help="Load LCM types from TYPESDIRS", metavar="TYPESDIRS", action="append", default=[])

    (options, args) = parser.parse_args()

    lcm_classes = load_lcm_modules(options.types)
    state = LCMState()

    palette = [("item.normal", "", ""),
        ("item.focus", "black", "yellow"),
        ("item.header", "bold,yellow", "")]
    table = Table(header, layout, callback=show_data)
    channels = urwid.LineBox(table.widget())
    data_table = Table(data_header, data_layout, divided=True)
    data = urwid.LineBox(data_table.widget())
    display = urwid.Columns(urwid.SimpleFocusListWalker([channels, data]))
    status = LCMStatusBar()
    top = urwid.Frame(display, footer=status)
    loop = urwid.MainLoop(top, unhandled_input=handle_input, palette=palette)
    node = lcm.LCM()
    lcm_thread = threading.Thread(target=handle_lcm, args=(node, table))
    lcm_thread.setDaemon(True)
    lcm_thread.start()
    loop.set_alarm_in(1 / state._refresh_rate, refresh_screen)
    loop.run()
